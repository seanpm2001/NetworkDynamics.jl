var documenterSearchIndex = {"docs":
[{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"EditURL = \"../../examples/getting_started_with_network_dynamics.jl\"","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#getting_started","page":"Getting started","title":"Network diffusion","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Theoretical-background","page":"Getting started","title":"Theoretical background","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. Then the rate of change of state v_i is described by its difference with its neighbors and we obtain the following ordinary differential equation","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v_i = sum_j=1^N A_ji (v_j - v_i)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Modeling-diffusion-in-NetworkDynamics.jl","page":"Getting started","title":"Modeling diffusion in NetworkDynamics.jl","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then A_ji = 0  forall j and hence dot v_i = 0. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl, interactions with neighbors are described by equations for the edges.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"using Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEq\nusing Plots\n\nfunction diffusionedge!(e, v_s, v_d, p, t)\n    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\n    e .= v_s .- v_d\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The function diffusionedge! takes as inputs the current state of the edge e, its source vertex v_s, its destination vertex v_d, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, even though we do not need p and t for the diffusion example.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"diffusionedge! is called a mutating function, since it modifies (or mutates) one of its inputs, namely the edge state e. As a convention in Julia names of mutating functions end with an !. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge's value e equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The contributions of the different edges are then summed up in each vertex.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"function diffusionvertex!(dv, v, esum, p, t)\n    # usually v, edges are arrays, hence we use the broadcasting operator .\n    dv .= esum\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Just like above the input arguments v, esum, p, t are mandatory for the syntax of vertex functions. The additional input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary differential equations.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"For undirected graphs, the edgefunction! specifies the coupling from a source- to a destination vertex. The contributions of the connected edges to a single vertex are \"aggregated\". Default aggregation is the summation of all incident edge states. The aggregated edge state is made available via the esum argument of the vertex function.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Constructing-the-network","page":"Getting started","title":"Constructing the network","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"N = 20 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The Barabási–Albert model generates a scale-free random graph.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"nd_diffusion_vertex = ODEVertex(; f=diffusionvertex!, dim=1)\nnd_diffusion_edge = StaticEdge(; f=diffusionedge!, dim=1, coupling=AntiSymmetric())\n\nnd = Network(g, nd_diffusion_vertex, nd_diffusion_edge)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"ODEVertex and StaticEdge are functions wrappers that equip the functions we defined above with additional information like dim and return objects of type VertexFunction and EdgeFunction. Then the key constructor Network combines them with the topological information contained in the graph g and returns an ODEFunction compatible with the solvers of DifferentialEquations.jl. The keyword dim specifies the number of variables at each edge or node.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"x0 = randn(N) # random initial conditions\node_prob = ODEProblem(nd, x0, (0.0, 4.0))\nsol = solve(ode_prob, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"We are solving the diffusion problem on the time interval 0 4 with the Tsit5() algorithm, which is recommended  by the authors of DifferentialEquations.jl for most non-stiff problems.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"plot(sol; idxs=vidxs(nd, :, :), fmt=:png)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The plotting is straightforward. The idxs keyword allows us to pass a list of indices. Indeces can be also \"symbolic\" indices which specify components and their symbols directly. For example idxs = VIndex(1, :v) acesses state :v of vertex 1.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"In oder to collect multiple indices we can use the helper function vidxs and eidxs, which help to collect all symbolic indices matching a certain criteria.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol x and is started with initial conditions drawn from the standard normal distribution N(01), the second uses the symbol ϕ with squared standard normal inital conditions.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The symbols have to be passed with the keyword sym to ODEVertex.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"N = 10 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\n# We will have two independent diffusions on the network, hence dim = 2\nnd_diffusion_vertex_2 = ODEVertex(; f=diffusionvertex!, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = StaticEdge(; f=diffusionedge!, dim=2, sym=[:flow_x, :flow_ϕ], coupling=AntiSymmetric())\nnd_2 = Network(g, nd_diffusion_vertex_2, nd_diffusion_edge_2)\n\nx0_2 = vec(transpose([randn(N) .^ 2 randn(N)])) # x ~ N(0,1)^2; ϕ ~ N(0,1)\node_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))\nsol_2 = solve(ode_prob_2, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Try plotting the variables ϕ_i yourself. [To write ϕ type \\phi and press TAB]","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"plot(sol_2; idxs=vidxs(nd_2, :, :x), fmt=:png)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Using the eidxs helper function we can also plot the flow variables","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"plot(sol_2; idxs=eidxs(nd_2, :, :flow_x), fmt=:png)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L","page":"Getting started","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The diffusion equation on a network can be rewritten as","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v_i  = sum_j=1^N A_ji v_j - d_i v_i =  e_i^T A v - d_i v_i","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"where d_i is the degree of node i and e_i^T is the i-th standard basis vector. Introducing the diagonal matrix D that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v = e_i^T(A - D) v","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"and finally","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v = - L v","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L. For this reason L is an important construction in network science.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"EditURL = \"../../examples/directed_and_weighted_graphs.jl\"","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain","page":"Directed and weighted graphs","title":"Neurodynamic model of synchronization in the human brain","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:","page":"Directed and weighted graphs","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"page"},{"location":"generated/directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model","page":"Directed and weighted graphs","title":"The FitzHugh-Nagumo model","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Here u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Coupling-relaxation-oscillators","page":"Directed and weighted graphs","title":"Coupling relaxation oscillators","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#The-network-topology-a-brain-atlas","page":"Directed and weighted graphs","title":"The network topology - a brain atlas","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In the following we will use a directed and weighted network encoding the strength and directionality of coupling between 90 different areas of the brain [Nathalie Tzourio-Mazoyer et al., 2002, Neuroimage].","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using DelimitedFiles\nusing SimpleWeightedGraphs, Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEq\nusing Plots\n\n# adjust the load path for your filesystem!\nfile = joinpath(pkgdir(NetworkDynamics), \"docs\", \"examples\", \"Norm_G_DTI.txt\")\nG = readdlm(file, ',', Float64, '\\n')\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on Graphs.jl.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\n\n# we promote the g_weighted graph as a directed graph (weights of the edges are included in parameters)\ng_directed = SimpleDiGraph(g_weighted)\n\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Setting-up-the-ODEProblem","page":"Directed and weighted graphs","title":"Setting up the ODEProblem","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Defining VertexFunction and EdgeFunction is similar to the example before. The macro Base.@propagate_inbounds tells the compiler to inline the function and propagate the inbounds context. For more details see the julia documentation.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Base.@propagate_inbounds function fhn_electrical_vertex!(dv, v, esum, p, t)\n    (a, ϵ) = p\n    dv[1] = v[1] - v[1]^3 / 3 - v[2] + esum[1]\n    dv[2] = (v[1] - a) * ϵ\n    nothing\nend\nodeelevertex = ODEVertex(fhn_electrical_vertex!; sym=[:u, :v], psym=[:a=>0.5, :ϵ=>0.05])","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Base.@propagate_inbounds function electrical_edge!(e, v_s, v_d, (w, σ), t)\n    e[1] = w * (v_s[1] - v_d[1]) * σ\n    nothing\nend\nelectricaledge = StaticEdge(electrical_edge!; dim=1, psym=[:weight, :σ=>0.5], coupling=Directed())","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"fhn_network! = Network(g_directed, odeelevertex, electricaledge)","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Since this system is a directed one with thus directed edges, the keyword argument coupling is used to set the coupling of the edges to Directed().","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Parameter-handling","page":"Directed and weighted graphs","title":"Parameter handling","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Some of the parameters have been declared with default values. Those default values will be used when creating the NWParameter object. We can use getindex on the parameter objects to set the missing weight values.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"p = NWParameter(fhn_network!)\np.e[1:ne(g_directed), :weight] = edge_weights\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The initial conditions could be created similarly to the parameters as an indexable NWState obejct. Since we chose a random initial condition we initialize the flat array directly:","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"x0 = randn(dim(fhn_network!)) * 5\n\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Solving-the-system","page":"Directed and weighted graphs","title":"Solving the system","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Not that we call pflat on the NWParameter object to get the flat array of parameters.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"tspan = (0.0, 200.0)\nprob  = ODEProblem(fhn_network!, x0, tspan, pflat(p))\nsol = solve(prob, AutoTsit5(TRBDF2()));\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Plotting","page":"Directed and weighted graphs","title":"Plotting","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"plot(sol; idxs=vidxs(fhn_network!, :, :u), legend=false, ylim=(-5, 5), fmt=:png)","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Library/#API","page":"API","title":"API","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"The following functions are designed for public use","category":"page"},{"location":"Library/","page":"API","title":"API","text":"","category":"page"},{"location":"Library/#Network-Construction","page":"API","title":"Network Construction","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"Network\ndim\npdim","category":"page"},{"location":"Library/#NetworkDynamics.Network","page":"API","title":"NetworkDynamics.Network","text":"Network(nw::Network; kwargs...)\n\nRebuild the Network with same graph and vertex/edge functions but possibly different kwargs.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.dim","page":"API","title":"NetworkDynamics.dim","text":"dim(nw::Network)\n\nReturns the number of dynamic states in the network, corresponts to the length of the flat state vector.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.pdim","page":"API","title":"NetworkDynamics.pdim","text":"pdim(nw::Network)\n\nReturns the number of parameters in the network, corresponts to the length of the flat parameter vector.\n\n\n\n\n\n","category":"function"},{"location":"Library/#Vertex-Functions","page":"API","title":"Vertex Functions","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"StaticVertex\nODEVertex","category":"page"},{"location":"Library/#NetworkDynamics.ODEVertex","page":"API","title":"NetworkDynamics.ODEVertex","text":"struct ODEVertex{F, OF, MM} <: NetworkDynamics.VertexFunction\n\nFields\n\nname\nf\ndim\nsym\ndef\ndepth\npdim\npsym\npdef\nobsf\nobssym\nmass_matrix\n\n\n\n\n\n","category":"type"},{"location":"Library/#Edge-Functions","page":"API","title":"Edge Functions","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"StaticEdge\nODEEdge","category":"page"},{"location":"Library/#Coupling-types","page":"API","title":"Coupling types","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"Symmetric\nAntiSymmetric\nDirected\nFiducial","category":"page"},{"location":"Library/#NetworkDynamics.Symmetric","page":"API","title":"NetworkDynamics.Symmetric","text":"struct Symmetric <: Coupling end\n\nSymmetric coupling type. The edge function f is evaluated once:\n\nthe dst vertex receives the first d values of the edge state,\nthe src vertex receives the same.\n\nHere, d is the edge depth of the Network.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.AntiSymmetric","page":"API","title":"NetworkDynamics.AntiSymmetric","text":"struct AntiSymmetric <: Coupling end\n\nAntiSymmetric coupling type. The edge function f is evaluated once:\n\nthe dst vertex receives the first d values of the edge state,\nthe src vertex receives (-1) of that.\n\nHere, d is the edge depth of the Network.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.Directed","page":"API","title":"NetworkDynamics.Directed","text":"struct Directed <: Coupling end\n\nDirected coupling type. The edge function f is evaluated once:\n\nthe dst vertex receives the first d values of the edge state,\nthe src vertex receives nothing.\n\nHere, d is the edge depth of the Network.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.Fiducial","page":"API","title":"NetworkDynamics.Fiducial","text":"struct Fiducial <: Coupling end\n\nFiducial coupling type. The edge function f is evaluated once:\n\nthe dst vertex receives the 1:d values of the edge state,\nthe src vertex receives the d+1:2d values of the edge state.\n\nHere, d is the edge depth of the Network.\n\n\n\n\n\n","category":"type"},{"location":"Library/#Symbolic-Indexing","page":"API","title":"Symbolic Indexing","text":"","category":"section"},{"location":"Library/#Network-State-Object","page":"API","title":"Network State Object","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"NWState\nNWState(::Any)\nNWState(::NWState)\nNWState(::NWParameter)\nNWState(::SciMLBase.DEIntegrator)","category":"page"},{"location":"Library/#NetworkDynamics.NWState","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper, uflat, [pflat], [t])\n\nIndexable wrapper for flat state & parameter array. Needs Network or wrapper of Network, e.g. ODEProblem.\n\ns = NWState(nw)\ns.v[idx, :sym] # get state :sym of vertex idx\ns.e[idx, :sym] # get state :sym of edge idx\ns.p.v[idx, :sym] # get parameter :sym of vertex idx\ns.p.e[idx, :sym] # get parameter :sym of edge idx\ns[s::Union{VIndex, EIndex, EPIndex, VPIndex}] # get parameter for specific index\n\nGet flat array representation using uflat(s) and pflat(s).\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NWState-Tuple{Any}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper;\n        utype=Vector{Float64}, ufill=filltype(utype),\n        ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWState object for the Network/Wrapper nw with flat types utype & ptype. The arrays will be prefilled with ufill and pfill respectively (defaults to NaN).\n\nIf default=true the default state & parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"Library/#NetworkDynamics.NWState-Tuple{NWState}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(p::NWState; utype=typeof(uflat(s)), ptype=typeof(pflat(s)))\n\nCreate NWState based on other state object, just convert types.\n\n\n\n\n\n","category":"method"},{"location":"Library/#NetworkDynamics.NWState-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(p::NWParameter; utype=Vector{Float64}, ufill=filltype(utype), default=true)\n\nCreate NWState based on existing NWParameter object.\n\n\n\n\n\n","category":"method"},{"location":"Library/#NetworkDynamics.NWState-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(int::SciMLBase.DEIntegrator)\n\nCreate NWState object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"Library/#Network-Parameter-Object","page":"API","title":"Network Parameter Object","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"NWParameter\nNWParameter(::Any)\nNWParameter(::NWParameter)\nNWParameter(::SciMLBase.DEIntegrator)","category":"page"},{"location":"Library/#NetworkDynamics.NWParameter","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wraper, pflat)\n\nIndexable wrapper for flat parameter array pflat. Needs Network or wrapper of Network, e.g. ODEProblem.\n\np = NWParameter(nw)\np.v[idx, :sym] # get parameter :sym of vertex idx\np.e[idx, :sym] # get parameter :sym of edge idx\np[s::Union{VPIndex, EPIndex}] # get parameter for specific index\n\nGet flat array representation using pflat(p).\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NWParameter-Tuple{Any}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wraper;\n            ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWParameter object for the Network/Wrapper nw with flat type ptype. The array will be prefilled with pfill (defaults to NaN).\n\nIf default=true the default parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"Library/#NetworkDynamics.NWParameter-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(p::NWParameter; ptype=typeof(p.pflat))\n\nCreate NWParameter based on other parameter object, just convert type.\n\n\n\n\n\n","category":"method"},{"location":"Library/#NetworkDynamics.NWParameter-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(int::SciMLBase.DEIntegrator)\n\nCreate NWParameter object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"Library/#Index-generators","page":"API","title":"Index generators","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"vidxs\neidxs\nvpidxs\nepidxs","category":"page"},{"location":"Library/#NetworkDynamics.vidxs","page":"API","title":"NetworkDynamics.vidxs","text":"vidxs([inpr], components=:, variables=:) :: Vector{VIndex}\n\nGenerate vector of symbolic indexes for vertices.\n\ninpr: Only needed for name matching or : access. Can be Network, sol, prob, ...\ncomponents: Number/Vector, :, Symbol (name matches), String/Regex (name contains)\nvariables: Symbol/Number/Vector, :, String/Regex (all sym containing)\n\nExamples:\n\nvidxs(nw)                 # all vertex state indices\nvidxs(1:2, :u)            # [VIndex(1, :u), VIndex(2, :u)]\nvidxs(nw, :, [:u, :v])    # [VIndex(i, :u), VIndex(i, :v) for i in 1:nv(nw)]\nvidxs(nw, \"ODEVertex\", :) # all symbols of all vertices with name containing \"ODEVertex\"\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.eidxs","page":"API","title":"NetworkDynamics.eidxs","text":"vidxs([inpr], components=:, variables=:) :: Vector{EIndex}\n\nGenerate vector of symbolic indexes for edges.\n\ninpr: Only needed for name matching or : access. Can be Network, sol, prob, ...\ncomponents: Number/Vector, :, Symbol (name matches), String/Regex (name contains)\nvariables: Symbol/Number/Vector, :, String/Regex (all sym containing)\n\nExamples:\n\neidxs(nw)                # all edge state indices\neidxs(1:2, :u)           # [EIndex(1, :u), EIndex(2, :u)]\neidxs(nw, :, [:u, :v])   # [EIndex(i, :u), EIndex(i, :v) for i in 1:ne(nw)]\neidxs(nw, \"FlowEdge\", :) # all symbols of all edges with name containing \"FlowEdge\"\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.vpidxs","page":"API","title":"NetworkDynamics.vpidxs","text":"vpidxs([inpr], components=:, variables=:) :: Vector{VPIndex}\n\nGenerate vector of symbolic indexes for parameters. See vidxs for more information.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.epidxs","page":"API","title":"NetworkDynamics.epidxs","text":"epidxs([inpr], components=:, variables=:) :: Vector{EPIndex}\n\nGenerate vector of symbolic indexes for parameters. See eidxs for more information.\n\n\n\n\n\n","category":"function"},{"location":"Library/#Symbolic-Indices","page":"API","title":"Symbolic Indices","text":"","category":"section"},{"location":"Library/","page":"API","title":"API","text":"VIndex\nEIndex\nVPIndex\nEPIndex","category":"page"},{"location":"Library/#NetworkDynamics.VIndex","page":"API","title":"NetworkDynamics.VIndex","text":"VIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VIndex(comp, sub)\n\nA symbolic index for a vertex state variable.\n\ncomp: the component index, either int or a collection of ints\nsub: the subindex, either int, symbol or a collection of those.\n\nVIndex(1, :P)      # vertex 1, variable :P\nVIndex(1:5, 1)     # first state of vertices 1 to 5\nVIndex(7, (:x,:y)) # states :x and :y of vertex 7\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nSee also: EIndex, VPIndex, EPIndex\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.EIndex","page":"API","title":"NetworkDynamics.EIndex","text":"EIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = EIndex(comp, sub)\n\nA symbolic index for an edge state variable.\n\ncomp: the component index, either int or a collection of ints\nsub: the subindex, either int, symbol or a collection of those.\n\nEIndex(1, :P)      # edge 1, variable :P\nEIndex(1:5, 1)     # first state of edges 1 to 5\nEIndex(7, (:x,:y)) # states :x and :y of edge 7\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nSee also: VIndex, VPIndex, EPIndex\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.VPIndex","page":"API","title":"NetworkDynamics.VPIndex","text":"VPIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VPIndex(comp, sub)\n\nA symbolic index into the parameter a vertex:\n\ncomp: the component index, either int or a collection of ints\nsub: the subindex, either int, symbol or a collection of those.\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWParameter or ODEProblem.\n\nSee also: EPIndex, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.EPIndex","page":"API","title":"NetworkDynamics.EPIndex","text":"VEIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VEIndex(comp, sub)\n\nA symbolic index into the parameter a vertex:\n\ncomp: the component index, either int or a collection of ints\nsub: the subindex, either int, symbol or a collection of those.\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWParameter or ODEProblem.\n\nSee also: VPIndex, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"EditURL = \"../../examples/heterogeneous_system.jl\"","category":"page"},{"location":"generated/heterogeneous_system/#Modeling-a-heterogeneous-system","page":"Heterogeneous systems","title":"Modeling a heterogeneous system","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"One of the main purposes of NetworkDynamics.jl is to facilitate modeling coupled systems with heterogenities. This means that components can differ in their parameters as well as in their dynamics.","category":"page"},{"location":"generated/heterogeneous_system/#Heterogenous-parameters","page":"Heterogeneous systems","title":"Heterogenous parameters","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"We start by setting up a simple system of Kuramoto oscillators.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"using NetworkDynamics, OrdinaryDiffEq, Plots, Graphs\n\nN = 8\ng = watts_strogatz(N, 2, 0) # ring network\n\nfunction kuramoto_edge!(e, θ_s, θ_d, (K,), t)\n    e[1] = K * sin(θ_s[1] - θ_d[1])\n    nothing\nend\n\nfunction kuramoto_vertex!(dθ, θ, esum, (ω,), t)\n    dθ[1] = ω + esum[1]\n    nothing\nend\n\nvertex! = ODEVertex(kuramoto_vertex!; sym=[:θ], psym=[:ω], name=:kuramoto)\n\nedge! = StaticEdge(kuramoto_edge!; dim=1, psym=[:K=>3], coupling=AntiSymmetric())\nnw = Network(g, vertex!, edge!);\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"To assign parameters, we can create a NWParameter object based on the nw definition. This parameter object will be pre-filled with the default parameters.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"p = NWParameter(nw)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"To set the node parameters, we can use indexing of the p.v field:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"ω = collect(1:N) ./ N\nω .-= sum(ω) / N\np.v[:, :ω] = ω\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Here, the index pairing :, :ω is used to index state ω for all node indices.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"The parameter object contains information about the network structure. For the actual problem definition we need to throw away this wrapper and use the flat-vector representation of the parameters pflat(p). Note that pflat(p)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Similarily, we could use NWState(nw) to create an indexable wrapper of the initial state. However in this case we can also fill create the flat state array manually:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0 = collect(1:N) ./ N\nx0 .-= sum(x0) ./ N\ntspan = (0.0, 10.0)\nprob = ODEProblem(nw, x0, tspan, pflat(p))\nsol = solve(prob, Tsit5())\nplot(sol; ylabel=\"θ\", fmt=:png)","category":"page"},{"location":"generated/heterogeneous_system/#Heterogeneous-dynamics","page":"Heterogeneous systems","title":"Heterogeneous dynamics","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Two paradigmatic modifications of the node model above are static nodes and nodes with inertia.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"A static node has no internal dynamics and instead fixes the variable at a constant value. There are two ways to achive such behavior in network dynamics. We can either create a StaticVertex which is implemented as an algebraic constraint, or we can create a node without dynamic (du = 0) and a specific initial value.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"static! = ODEVertex(sym=[:θ=>ω[1]], name=:static) do du, u, esum, p, t\n    du .= 0\n    nothing\nend","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Here we used a form of the ODEVertex constructor which allows us to specify default initial conditions.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"A Kuramoto model with inertia consists of two internal variables leading to more complicated (and for many applications more realistic) local dynamics.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"function kuramoto_inertia!(dv, v, esum, (ω,), t)\n    dv[1] = v[2]\n    dv[2] = ω - 1.0 * v[2] + esum[1]\n    nothing\nend\n\ninertia! = ODEVertex(kuramoto_inertia!; sym=[:θ, :ω], psym=[:ω], name=:inertia)\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Since now we model a system with heterogeneous node dynamics we can no longer straightforwardly pass a single VertexFunction to the Network constructor but instead have to hand over an Array.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"vertex_array    = ODEVertex[vertex! for i in 1:N]\nvertex_array[1] = static!\nvertex_array[5] = inertia! # index should correspond to the node's index in the graph\nnw_hetero! = Network(g, vertex_array, edge!)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Now we have to take a bit more care with defining initial conditions and parameters.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"First, we can generate a NWState object based on the nw_hetero! object which will be populated with the default values.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"state = NWState(nw_hetero!)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"The node with inertia is two-dimensional, hence we need to specify two initial conditions. For the first dimension we keep the initial conditions from above and insert! another one into x0 at the correct index.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"For the θ states we will use the same initial conditins as before:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"state.v[2:8,:θ] = x0[2:8]\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"We're still missing one initial condition: the second variable ω of the 5th vertex.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"state.v[5,:ω] = 5\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"The NWState object also contains a parameter object accessible via state.p. The edge parameters are already filled with default values. The vertex parameters can be copied from our old parmeter object p.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"state.p.v[2:8, :ω] = p.v[2:8, :ω]\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"For the problem construction, we need to convert the nested stuctures to flat arrays using the uflat and pflat methods.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"prob_hetero = ODEProblem(nw_hetero!, uflat(state), tspan, pflat(state))\nsol_hetero = solve(prob_hetero, Tsit5());\nnothing #hide\nplot(sol_hetero)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"For clarity we plot only the variables referring to the oscillator's angle θ and color them according to their type.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"colors = map(vertex_array) do vertexf\n    if vertexf.name == :kuramoto\n        colorant\"lightseagreen\"\n    elseif vertexf.name == :static\n        colorant\"orange\"\n    elseif vertexf.name == :inertia\n        colorant\"darkred\"\n    end\nend\n\nplot(sol_hetero; ylabel=\"θ\", idxs=vidxs(1:8,:θ), lc=colors', fmt=:png)","category":"page"},{"location":"generated/heterogeneous_system/#Components-with-algebraic-constraints","page":"Heterogeneous systems","title":"Components with algebraic constraints","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"If one of the network components contains an algebraic as well as dynamical component, then there is the option to supply a mass matrix for the given component. In general this will look as follows:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"function edgeA!(de, e, v_s, v_d, p, t)\n    de[1] = f(e, v_s, v_d, p, t) # dynamic variable\n    e[2]  = g(e, v_s, v_d, p, t) # static variable\nend\n\nM = zeros(2, 2)\nM[1, 1] = 1\n\nnd_edgeA! = ODEEdge(; f=edgeA!, dim=2, coupling=:undirected, mass_matrix=M);\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This handles the second equations as 0 = M[2,2] * de[2] = g(e, v_s, v_d, p, t) - e[2].","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"See the example kuramoto_plasticity.jl and the discussion on github for more details.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"EditURL = \"../../examples/cascading_failure.jl\"","category":"page"},{"location":"generated/cascading_failure/#Cascading-Failure","page":"Cascading failure","title":"Cascading Failure","text":"","category":"section"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"This script reimplements the minimal example of a dynamic cascading failure described in Schäfer et al. (2018) [1]. It is an example how to use callback functions to change network parameters. In this case to disable certain lines.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"[1] Schäfer, B., Witthaut, D., Timme, M., & Latora, V. (2018). Dynamically induced cascading failures in power grids. Nature communications, 9(1), 1-13. https://www.nature.com/articles/s41467-018-04287-5","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"The system is modeled using swing equation and active power edges. The nodes are characterized by the voltage angle δ, the active power on each line is symmetric and a function of the difference between source and destination angle δ_src - δ_dst.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"using NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEq\nusing DiffEqCallbacks\nusing Plots\nimport SymbolicIndexingInterface as SII","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"For the nodes we define the swing equation. State v[1] = δ, v[2] = ω. The swing equation has three parameters: p = (P_ref, I, γ) where P_ref is the power setpopint, I is the inertia and γ is the droop or damping coeficcient.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"function swing_equation(dv, v, esum, p,t)\n    P, I, γ = p\n    dv[1] = v[2]\n    dv[2] = P - γ * v[2] .+ esum[1]\n    dv[2] = dv[2] / I\n    nothing\nend\nodevertex = ODEVertex(swing_equation; sym=[:δ, :ω], psym=[:P_ref, :I=>1, :γ=>0.1], depth=1)","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"Lets define a simple purely active power line whose active power flow is completlye determined by the connected voltage angles and the coupling constant K. We give an additonal parameter, the line limit, which we'll use later in the callback.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"function simple_edge(e, v_s, v_d, (K,), t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\nstaticedge = StaticEdge(simple_edge; sym=:P, psym=[:K=>1.63, :limit=>1], coupling=AntiSymmetric())","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"With the definition of the graph topology we can build the Network object:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"g = SimpleGraph([0 1 1 0 1;\n                 1 0 1 1 0;\n                 1 1 0 1 0;\n                 0 1 1 0 1;\n                 1 0 0 1 0])\nswing_network = Network(g, odevertex, staticedge)","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"For the parameters, we create the NWParameter object prefilled with default p values","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"p = NWParameter(swing_network)\n# vertices 1, 3 and 4 act as loads\np.v[(1,3,4), :P_ref] .= -1\n# vertices 2 and 5 act as generators\np.v[(2,5), :P_ref] .= 1.5\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"We can use find_fixpoint to find a valid initial condition of the network","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"u0 = find_fixpoint(swing_network, p)\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"In order to implement the line failures, we need to create a VectorContinousCallback. In the callback, we compare the current flow on the line with the limit. If the limit is reached, the coupling K is set to 0.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"First we can define the affect function:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"function affect!(integrator, idx)\n    println(\"Line $idx tripped at t=$(integrator.t)\")\n    p = NWParameter(integrator) # get indexable parameter object\n    p.e[idx, :K] = 0\n    auto_dt_reset!(integrator)\n    save_parameters!(integrator)\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"There is one important aspect to this function: the save_parameters call. In the callback, we change the parameters of the network, making the parameters time dependent. The flow on the line is a function P(t) = f(u(t), p(t)). Thus we need to inform the integrator, that a discrete change in parameters happend. With this, the solution object not only tracks u(t) but also p(t) and we may extract the observable P(t) directly.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"The callback trigger condition is a bit more complicated. The straight forward version looks like this:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"function naive_condition(out, u, t, integrator)\n    # careful,  u != integrator.u\n    # therefore construct nwstate with Network info from integrator but u\n    s = NWState(integrator, u, integrator.p, t)\n    for i in eachindex(out)\n        out[i] = abs(s.e[i,:P]) - s.p.e[1,:limit] # compare flow with limit for line\n    end\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"However, from a performacne perspectiv there are problems with this solution: on every call, we need to perform symbolic indexing into the NWState object. Symbolic indexing is not cheap, as it requires to gather meta data about the network. Luckily, the SymbolicIndexingInterface package which powers the symbolic indexing provides the lower level functions getp and getu which can be used to create and cache accessors to the internal states.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"This still isn't ideal beacuse both getlim and getflow getters will create arrays within the callback. But is far better then resolving the flat state indices every time.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"condition = let getlim = SII.getp(swing_network, epidxs(swing_network, :, :limit)),\n                getflow = SII.getu(swing_network, eidxs(swing_network, :, :P))\n    function (out, u, t, integrator)\n        # careful,  u != integrator.u\n        # therefore construct nwstate with Network info from integrator but u\n        s = NWState(integrator, u, integrator.p, t)\n        out .= getlim(s) .- abs.(getflow(s))\n        nothing\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"We can combine affect and condition to form the callback.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"trip_cb = VectorContinuousCallback(condition, affect!, ne(g));\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"However, there is another component missing. If we look at the powerflow on the lines in the initial steady state","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"u0.e[:, :P]","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"We see that every flow is below the trip value 1.0. Therefor we need to add a distrubance to the network. We do this by manually disabeling line 5 at time 1.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"trip_first_cb = PresetTimeCallback(1.0, integrator->affect!(integrator, 5));\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"With those components, we can create the problem and solve it.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"prob = ODEProblem(swing_network, uflat(u0), (0,6), copy(pflat(p));\n                  callback=CallbackSet(trip_cb, trip_first_cb))\nsol = solve(prob, Tsit5());\n\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"Through the magic of symbolic indexing we can plot the power flows on all lines:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"plot(sol; idxs=eidxs(sol,:,:P))","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading failure","title":"Cascading failure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"EditURL = \"../../examples/StochasticSystem.jl\"","category":"page"},{"location":"generated/StochasticSystem/#SDE-Tutorial","page":"Stochastic differential equations","title":"SDE Tutorial","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/StochasticSystem/#Topics-covered-in-this-tutorial-include:","page":"Stochastic differential equations","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"the swing equation\nfixpoint search of ODE systems\nconstructing an SDE problem with NetworkDynamics.jl","category":"page"},{"location":"generated/StochasticSystem/#Example:-Fluctuations-in-Power-Grids","page":"Stochastic differential equations","title":"Example: Fluctuations in Power Grids","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"This tutorial explains the use of stochastic differential equations (SDE's) in NetworkDynamics.jl. As an example system we will simulate fluctuations in a simple power grid model.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"The phase and frequency dynamics in power grids can be modeled by the swing equation. In the complex systems community this is also known as the Kuramoto model with inertia.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\ndot theta_i = omega_i \nM_i dot omega_i = P_i(t) - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)\nendaligned","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Here, M_i and D_i are inertia and damping parameters, K_ij is the power capacitiy of the line and P_i(t) is the power infeed at the node. We assume that this power can be separated into a constant power setpoint P^circ_i and a stochastic fluctuation.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\nP_i(t) = P^circ_i + sigma_i cdot xi_i(t)\nendaligned","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"In this tutorial we assume the fluctuations xi_i(t) to be white Gaussian noise. Separating the deterministic and stochastic part, we can write this problem as a stochastic differential equation.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\ndomega_i = leftP_i - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)right dt + sigma_i dW_i\nendaligned","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Here, dW_i = xi_i dt is the infinitesimal increment of the Wiener process. Problems of this type can be numerically solved in Julia as described in the SDE Tutorial of DifferentialEquations.","category":"page"},{"location":"generated/StochasticSystem/#Implementing-the-Swing-Equation","page":"Stochastic differential equations","title":"Implementing the Swing Equation","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"First we will implement the node and edge functions for the deterministic case without the fluctuations. We set the defaults for the inertia and damping parameters to be M_i = 10 and D_i = 01. The default coupling strength is K=6.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"using NetworkDynamics, Graphs\nusing StochasticDiffEq, OrdinaryDiffEq\nusing Plots, LaTeXStrings\n\nfunction swing_equation!(dv, v, esum, (M, P, D), t)\n    dv[1] = v[2]\n    dv[2] = 1/M *(P - D * v[2] + esum[1])\n    nothing\nend\nswing_vertex = ODEVertex(swing_equation!; sym=[:θ, :ω], psym=[:M=>1, :P, :D=>0.1])","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"function powerflow!(e, v_s, v_d, (K,), t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\npowerflow_edge = StaticEdge(powerflow!; dim=1, psym=[:K=>6], coupling=AntiSymmetric())","category":"page"},{"location":"generated/StochasticSystem/#Contructing-the-Deterministic-Dynamics","page":"Stochastic differential equations","title":"Contructing the Deterministic Dynamics","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"For the graph structure we will use a simple 4 node ring network.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"g = watts_strogatz(4, 2, 0.0)\nnothing #hide","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Then we can construct the Network of the deterministic system.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"nd = Network(g, swing_vertex, powerflow_edge)","category":"page"},{"location":"generated/StochasticSystem/#Fixpoint-Search","page":"Stochastic differential equations","title":"Fixpoint Search","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Now we need to define the dynamic parameters of vertices and edges. For that, we start by creating the NWParameter object, pre filling it with the default values:","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"p = NWParameter(nd)","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Most of the parameters are allready set For the nodes we assume half of them to be net producers (P = 10) and half of them to be net consumers (P = -10) of power.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"p.v[1:4, :P] = [1, -1, 1, -1]\nnothing #hide","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"We want to simulate fluctuations around an equilibrium state of our model system. Therefore, we need to find a fixpoint of the determinitic system which can be done by using the utility function find_fixpoint(). As an initial guess we take all variables equal to zero.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"u0 = find_fixpoint(nd, p)\n\node_prob = ODEProblem(nd, uflat(u0), (0.0, 500.0), pflat(p))\node_sol = solve(ode_prob, Tsit5())\n\nplot(ode_sol; idxs=vidxs(nd,:,:ω), ylims=(-1.0, 1.0), ylabel=L\"\\omega\", legend=false, fmt=:png)","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"We see that this is in fact a fixpoint solution. We will later use this as an initial condition for the numerical integration of the SDE system.","category":"page"},{"location":"generated/StochasticSystem/#Adding-a-Stochastic-Layer","page":"Stochastic differential equations","title":"Adding a Stochastic Layer","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"For adding the stochastic part of the dynamics we have to define a second graph layer. In our example, the fluctuations at different nodes are independent of each other. Therefore, we define a second graph with the same number of vertices but without any edges.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"h = SimpleGraph(4, 0)\nnothing #hide","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"The dynamics at the nodes has to have the same dimension as in the deterministic case. In our example we only have fluctuations in the second variable.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"function fluctuation!(dx, x, edges, p, t)\n    dx[1] = 0.0\n    dx[2] = 0.05\nend\nnothing #hide","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Now we can construct the dynamics of the second layer by using network_dynamics(). Since the graph structure of the stochastic layer has no edges we can take the edge function of the deterministic case as a placeholder.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"fluctuation_vertex = ODEVertex(fluctuation!; dim=2)\nnd_noise = Network(h, fluctuation_vertex, NetworkDynamics.EdgeFunction[])\nnothing #hide","category":"page"},{"location":"generated/StochasticSystem/#Simulating-the-SDE","page":"Stochastic differential equations","title":"Simulating the SDE","text":"","category":"section"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Finally, we can create an SDEProblem and solve it with DifferentialEquations.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"sde_prob = SDEProblem(nd, nd_noise, uflat(u0), (0.0, 500.0), pflat(p))\nsde_sol = solve(sde_prob, SOSRA())\nplot(sde_sol; idxs=vidxs(nd,:,:ω), ylims=(-1.0, 1.0), ylabel=L\"\\omega\", legend=false, fmt=:png)","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"More details on SDE problems, e.g. how to include correlations or how to define an EnsembleProblem, can be found in the documentation of DifferentialEquations.","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"","category":"page"},{"location":"generated/StochasticSystem/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#NetworkDynamics","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"A package for working with dynamical systems on complex networks. NetworkDynamics.jl provides an interface between Graphs.jl and DifferentialEquations.jl. It allows to define several types of dynamic and static nodes and edges and to link them up in order to create complex network dynamics.","category":"page"},{"location":"","page":"General","title":"General","text":"The behavior of a node or an edge can be described by algebraic equations, by differential algebraic equation (DAEs) in mass matrix form or by ordinary differential equations (ODE). Stochastic ordinary differential equations (SDE) can e.g. be implemented as a two-layer network. For detail see the tutorials section.","category":"page"},{"location":"#Installation","page":"General","title":"Installation","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Installation is straightforward with Julia's package manager.","category":"page"},{"location":"","page":"General","title":"General","text":"(v1.10) pkg> add NetworkDynamics","category":"page"},{"location":"#PowerDynamics","page":"General","title":"PowerDynamics","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"PowerDynamics.jl is an open-source framework for dynamic power grid modeling and analysis build on top of NetworkDynamics.jl.","category":"page"},{"location":"#Overview","page":"General","title":"Overview","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"The central construction is the function network_dynamics that receives functions describing the local dynamics on the edges and nodes of a graph g as inputs, and returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"","page":"General","title":"General","text":"nd = network_dynamics(vertices!,  edges!, g)\nnd(dx, x, p, t)","category":"page"},{"location":"#Reproducibility","page":"General","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"<details><summary>Direct dependencies used for this documentation:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"},{"location":"","page":"General","title":"General","text":"<details><summary>Julia Version:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"},{"location":"","page":"General","title":"General","text":"<details><summary>Full Manifest:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"}]
}
